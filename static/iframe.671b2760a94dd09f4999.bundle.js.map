{"version":3,"file":"static/iframe.671b2760a94dd09f4999.bundle.js","sources":["webpack:///./app/components/shared/formatters/utils.ts"],"sourcesContent":["import BigNumber from \"bignumber.js\";\n\nimport { DEFAULT_DECIMAL_PLACES, MONEY_DECIMALS } from \"../../../config/constants\";\nimport { Opaque } from \"../../../types\";\nimport { invariant } from \"../../../utils/invariant\";\n\nexport enum ERoundingMode {\n  UP = \"up\",\n  DOWN = \"down\",\n  HALF_UP = \"half_up\",\n  HALF_DOWN = \"half_down\",\n}\n\nexport enum ENumberInputFormat {\n  ULPS = \"ulps\",\n  FLOAT = \"float\",\n}\n\nexport enum ECurrency {\n  NEU = \"neu\",\n  EUR = \"eur\",\n  EUR_TOKEN = \"eur_t\",\n  ETH = \"eth\",\n}\n\nexport enum ENumberFormat {\n  PERCENTAGE = \"percentage\",\n}\n\nexport enum EPriceFormat {\n  EQUITY_TOKEN_PRICE_ETH = \"equityTokenPriceEth\",\n  EQUITY_TOKEN_PRICE_EURO = \"equityTokenPriceEuro\",\n  EQUITY_TOKEN_PRICE_EUR_TOKEN = \"equityTokenPriceEuroToken\",\n  SHARE_PRICE = \"sharePrice\",\n}\n\nexport enum ENumberOutputFormat {\n  INTEGER = \"integer\",\n  ONLY_NONZERO_DECIMALS = \"onlyNonzeroDecimals\", // see removeZeroDecimals unit test\n  FULL = \"full\",\n  ONLY_NONZERO_DECIMALS_ROUND_UP = \"onlyNonzeroDecimalsRoundUp\", // see removeZeroDecimals unit test\n  FULL_ROUND_UP = \"fullRoundUp\",\n}\n\nexport enum EAbbreviatedNumberOutputFormat {\n  LONG = \"long\",\n  SHORT = \"short\",\n}\n\nexport type THumanReadableFormat = ENumberOutputFormat | EAbbreviatedNumberOutputFormat;\n\nexport enum ESpecialNumber {\n  UNLIMITED = \"unlimited\",\n}\n\nexport type EquityToken = Opaque<\"EquityToken\", string>;\n\nexport type TValueFormat = ECurrency | EPriceFormat | ENumberFormat | EquityToken;\n\ninterface IToFixedPrecision {\n  value: string | BigNumber | number;\n  roundingMode?: ERoundingMode;\n  inputFormat?: ENumberInputFormat;\n  decimalPlaces: number | undefined;\n  isPrice?: boolean;\n  outputFormat?: THumanReadableFormat;\n}\n\ninterface IFormatNumber {\n  value: string | BigNumber | number;\n  roundingMode?: ERoundingMode;\n  inputFormat?: ENumberInputFormat;\n  decimalPlaces?: number;\n  isPrice?: boolean;\n  outputFormat?: THumanReadableFormat;\n}\n\nexport const selectDecimalPlaces = (\n  valueType: TValueFormat,\n  outputFormat: THumanReadableFormat = ENumberOutputFormat.FULL,\n): number => {\n  if (\n    outputFormat !== ENumberOutputFormat.FULL &&\n    outputFormat !== ENumberOutputFormat.FULL_ROUND_UP &&\n    outputFormat !== ENumberOutputFormat.ONLY_NONZERO_DECIMALS &&\n    outputFormat !== ENumberOutputFormat.ONLY_NONZERO_DECIMALS_ROUND_UP\n  ) {\n    return 0;\n  } else {\n    switch (valueType) {\n      case EPriceFormat.SHARE_PRICE:\n      case ECurrency.EUR:\n      case ECurrency.EUR_TOKEN:\n      case ENumberFormat.PERCENTAGE:\n        return 2;\n      case EPriceFormat.EQUITY_TOKEN_PRICE_ETH:\n      case EPriceFormat.EQUITY_TOKEN_PRICE_EURO:\n      case EPriceFormat.EQUITY_TOKEN_PRICE_EUR_TOKEN:\n      case ECurrency.ETH:\n      case ECurrency.NEU:\n      default:\n        return DEFAULT_DECIMAL_PLACES;\n    }\n  }\n};\n\nexport const convertFromUlps = (value: BigNumber, baseFactor: number) =>\n  value.div(new BigNumber(10).pow(baseFactor));\n\nexport function formatThousands(value?: string): string {\n  // todo remove optionality. This function should accept string only. Leave for now for backward compat.\n  if (!value) return \"\";\n  const splitByDot = value.split(\".\");\n\n  invariant(splitByDot.length <= 2, \"Can't format this number: \" + value);\n\n  const formattedBeforeDot = splitByDot[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \" \");\n\n  if (splitByDot.length === 2) {\n    return `${formattedBeforeDot}.${splitByDot[1]}`;\n  }\n  return formattedBeforeDot;\n}\n\nexport const removeZeroDecimals = (value: string): string => {\n  const splitByDot = value.split(\".\");\n  invariant(splitByDot.length <= 2, \"Can't format this number: \" + value);\n  if (splitByDot[1] !== undefined && splitByDot[1].match(/^0+$/g)) {\n    return splitByDot[0];\n  } else {\n    return value;\n  }\n};\n\n//TODO sorry for any. Bignumber doesn't expose RoundingMode so there's no easy solution for it\nfunction getBigNumberRoundingMode(\n  roundingMode: ERoundingMode,\n  outputFormat: THumanReadableFormat = ENumberOutputFormat.FULL,\n): any {\n  if (\n    outputFormat === ENumberOutputFormat.FULL_ROUND_UP ||\n    outputFormat === ENumberOutputFormat.ONLY_NONZERO_DECIMALS_ROUND_UP\n  ) {\n    return BigNumber.ROUND_UP;\n  } else if (outputFormat === ENumberOutputFormat.INTEGER) {\n    return BigNumber.ROUND_HALF_DOWN;\n  } else {\n    switch (roundingMode) {\n      case ERoundingMode.DOWN:\n        return BigNumber.ROUND_DOWN;\n      case ERoundingMode.HALF_DOWN:\n        return BigNumber.ROUND_HALF_DOWN;\n      case ERoundingMode.HALF_UP:\n        return BigNumber.ROUND_HALF_UP;\n      case ERoundingMode.UP:\n      default:\n        return BigNumber.ROUND_UP;\n    }\n  }\n}\n\nexport const toFixedPrecision = ({\n  value,\n  roundingMode = ERoundingMode.UP,\n  inputFormat = ENumberInputFormat.ULPS,\n  decimalPlaces = undefined,\n  outputFormat = ENumberOutputFormat.FULL,\n}: IToFixedPrecision): string => {\n  invariant(\n    value !== null &&\n      (typeof value === \"string\" || typeof value === \"number\" || value instanceof BigNumber) &&\n      !(typeof value === \"string\" && value.trim() === \"\") &&\n      !(typeof value === \"number\" && (Number.isNaN(value) || !Number.isFinite(value))),\n    `cannot format this number: ${value} ${typeof value}`,\n  );\n\n  const dp = outputFormat === ENumberOutputFormat.INTEGER ? 0 : decimalPlaces;\n  const asBigNumber = value instanceof BigNumber ? value : new BigNumber(value.toString());\n\n  const moneyInPrimaryBase =\n    inputFormat === ENumberInputFormat.ULPS\n      ? convertFromUlps(asBigNumber, MONEY_DECIMALS)\n      : asBigNumber;\n  return moneyInPrimaryBase.toFixed(dp, getBigNumberRoundingMode(roundingMode, outputFormat));\n};\n\n/* formatNumber only formats numbers for display (!).\n * invalid input (null/undefined etc) should be handled before calling this fn, this one will only throw.\n * we don't check for strings in a wrong format here,\n * since 99% of input vals is from the store so it should be in the right format already,\n * and user input should handle this on its own before calling this fn\n * */\n/* SHORT and LONG formats are not handled by this fn, it's the job of the FormatShortNumber components */\nexport const formatNumber = ({\n  value,\n  roundingMode = ERoundingMode.DOWN,\n  inputFormat = ENumberInputFormat.ULPS,\n  decimalPlaces,\n  outputFormat = ENumberOutputFormat.FULL,\n}: IFormatNumber): string => {\n  const asFixedPrecisionNumber = toFixedPrecision({\n    value,\n    roundingMode,\n    inputFormat,\n    outputFormat,\n    decimalPlaces,\n  });\n\n  return outputFormat === ENumberOutputFormat.ONLY_NONZERO_DECIMALS ||\n    outputFormat === ENumberOutputFormat.ONLY_NONZERO_DECIMALS_ROUND_UP\n    ? formatThousands(removeZeroDecimals(asFixedPrecisionNumber))\n    : formatThousands(asFixedPrecisionNumber);\n};\n\nexport const parseInputToNumber = (val: string | undefined): string | null => {\n  if (!val || val.trim() === \"\") {\n    return \"\";\n  }\n\n  let value = val.trim().replace(/\\s/g, \"\");\n\n  if (value.match(/^\\d+$/)) {\n    return value;\n  }\n\n  const digits = value.match(/\\d|,|\\./g);\n  if (digits === null || digits.length < value.length) {\n    /* there are non-digit and non-separator characters: 123a,123 */\n    return null;\n  }\n\n  if (value.match(/^(\\d+([.,]))+\\d+$/) === null) {\n    /* 123. | 123, | ,123 | .123 | 123..123 | 123,,123 | 123.,123 */\n    return null;\n  }\n\n  const periods = value.match(/\\./g);\n  const commas = value.match(/,/g);\n  if (periods && periods.length > 1 && commas && commas.length > 1) {\n    /* 213.324.234,43,8 */\n    return null;\n  }\n  if (value.match(/\\d+\\.\\d+,\\d+\\./g) || value.match(/\\d+,\\d+\\.\\d+,/g)) {\n    return null; /* 123.123,123.123 || 123,123.123,123 */\n  }\n  if (periods && commas && (value.match(/(,\\d+){2,}$/) || value.match(/(\\.\\d+){2,}$/))) {\n    return null; /*123.123,123,123 | 123,123.123.123 */\n  }\n  if (periods && periods.length === 1 && commas && commas.length === 1) {\n    /* 222.222,22 | 222,222.22 */\n    value = value.replace(/([.,])(?=\\d+$)/, \".\");\n    value = value.replace(/(^\\d+)([.,])/, \"$1\");\n  }\n\n  if (periods && periods.length > 1) {\n    /* 213.213.44 thousands separators */\n    value = value.replace(/\\./g, \"\");\n  } else if (periods && periods.length === 1) {\n    /* 222.22 decimal sep */\n    // do nothing\n  }\n\n  if (commas && commas.length > 1) {\n    /* 213,213,44 thousands separators */\n    value = value.replace(/,/g, \"\");\n  } else if (commas && commas.length === 1) {\n    /* 222,22 decimal sep */\n    value = value.replace(/,/g, \".\");\n  }\n\n  return value;\n};\n\n/* this is only to check if the user input/formik value is empty */\nexport const isEmptyValue = (val: string | undefined) => val === undefined || val.trim() === \"\";\n\nexport const isValidNumber = (val: string | undefined) => {\n  if (!val) {\n    return false;\n  }\n  const value = val.trim().replace(/\\s/g, \"\");\n\n  return value.match(/^\\d+([.,]\\d+)?$/) !== null;\n};\n\nexport const stripNumberFormatting = (value: string) => {\n  if (isEmptyValue(value)) {\n    return \"\";\n  } else if (isValidNumber(value)) {\n    // remove whitespaces and trailing zeroes from decimal part if it's there\n    const splitValue = value.replace(/ /g, \"\").split(\".\");\n    invariant(\n      splitValue.length === 1 || splitValue.length === 2,\n      `stripNumberFormatting: Can't handle this input: \" ${value}`,\n    );\n\n    if (splitValue.length === 2) {\n      const trimmedValue = splitValue[1].replace(/0+$/, \"\");\n      return trimmedValue.length ? `${splitValue[0]}.${trimmedValue}` : splitValue[0];\n    } else {\n      return splitValue.join(\".\");\n    }\n  } else {\n    return value;\n  }\n};\n\nexport const selectUnits = (valueType: TValueFormat): string => {\n  switch (valueType) {\n    case ECurrency.ETH:\n    case EPriceFormat.EQUITY_TOKEN_PRICE_ETH:\n      return \"ETH\";\n    case ECurrency.NEU:\n      return \"NEU\";\n    case ECurrency.EUR:\n    case EPriceFormat.EQUITY_TOKEN_PRICE_EURO:\n    case EPriceFormat.SHARE_PRICE: //share prices are always in euro\n      return \"EUR\";\n    case ECurrency.EUR_TOKEN:\n    case EPriceFormat.EQUITY_TOKEN_PRICE_EUR_TOKEN:\n      return \"nEUR\";\n    case ENumberFormat.PERCENTAGE:\n      return \"%\";\n    default:\n      return valueType;\n  }\n};\n"],"mappings":"AAAA","sourceRoot":""}